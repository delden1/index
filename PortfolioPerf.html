#!/usr/bin/env python3
"""
Trade Snapshot Report Generator (subscriber-friendly)

Reads a TradesViz CSV export and produces a single, standalone HTML report that focuses on:
- Ease to Fill (volume-based proxy)
- Patience Window (how long winners typically take to peak)
- Typical Heat (how much drawdown is common while the trade is open)
- Peak Keep % (how much of the best unrealized profit was realized)

Usage:
  python trade_snapshot_report.py --input export-2.csv --output report.html
"""

from __future__ import annotations

import argparse
from pathlib import Path
import numpy as np
import pandas as pd


def _safe_to_datetime(s: pd.Series) -> pd.Series:
    return pd.to_datetime(s, errors="coerce", utc=True)


def _bucket_by_quantiles(values: pd.Series, labels: list[str]) -> pd.Series:
    """
    Buckets numeric values into len(labels) quantile buckets.
    Example labels for 3 buckets: ["Hard", "Normal", "Easy"]
    """
    v = values.astype(float)

    # If too few unique values, fall back to the middle label
    if v.nunique(dropna=True) < len(labels):
        return pd.Series([labels[len(labels) // 2]] * len(v), index=v.index)

    qs = np.linspace(0, 1, len(labels) + 1)
    cuts = v.quantile(qs).values

    # Ensure strictly increasing cut points
    for i in range(1, len(cuts)):
        if cuts[i] <= cuts[i - 1]:
            cuts[i] = cuts[i - 1] + 1e-9

    bins = [-np.inf] + list(cuts[1:-1]) + [np.inf]
    return pd.cut(v, bins=bins, labels=labels, include_lowest=True)


def build_report(df: pd.DataFrame) -> str:
    required = [
        "Symbol", "Tags", "Strikes",
        "Open Timestamp", "Close Timestamp",
        "PnL", "Current PnL",
        "Total Volume",
        "Trade MAE", "Trade MFE",
        "Time till MFE",
        "% Return", "Unrealized % Return",
    ]
    missing = [c for c in required if c not in df.columns]
    if missing:
        raise ValueError(f"CSV is missing required columns: {missing}")

    df = df.copy()

    # Parse timestamps
    df["Open Timestamp"] = _safe_to_datetime(df["Open Timestamp"])
    df["Close Timestamp"] = _safe_to_datetime(df["Close Timestamp"])

    # Status
    df["Status"] = np.where(df["Close Timestamp"].notna(), "Closed", "Open")

    # Effective PnL/%Return (closed uses realized; open uses current/unrealized)
    df["PnL_effective"] = np.where(
        df["Status"] == "Closed",
        pd.to_numeric(df["PnL"], errors="coerce"),
        pd.to_numeric(df["Current PnL"], errors="coerce"),
    )
    df["ReturnPct_effective"] = np.where(
        df["Status"] == "Closed",
        pd.to_numeric(df["% Return"], errors="coerce"),
        pd.to_numeric(df["Unrealized % Return"], errors="coerce"),
    )

    # 1) Ease to Fill (Replicability proxy) from Total Volume
    df["Total Volume"] = pd.to_numeric(df["Total Volume"], errors="coerce")
    df["Ease to Fill"] = _bucket_by_quantiles(df["Total Volume"], ["Hard", "Normal", "Easy"])

    # 2) Patience Window from Time till MFE (often exported in seconds)
    ttmfe = pd.to_numeric(df["Time till MFE"], errors="coerce")
    ttmfe = ttmfe.where(ttmfe >= 0)  # drop negative artifacts
    df["TimeToPeak_days"] = (ttmfe / 86400.0)

    # Fallback: use trade duration (Close - Open) when needed
    fallback_days = (df["Close Timestamp"] - df["Open Timestamp"]).dt.total_seconds() / 86400.0
    df["TimeToPeak_days"] = df["TimeToPeak_days"].fillna(fallback_days.where(fallback_days > 0))

    valid_peak = df["TimeToPeak_days"].dropna()
    df["Patience Window"] = _bucket_by_quantiles(df["TimeToPeak_days"], ["Fast", "Medium", "Slow"]) if len(valid_peak) >= 5 else "Medium"

    # 3) Typical Heat from Trade MAE (use absolute value; MAE usually negative)
    mae = pd.to_numeric(df["Trade MAE"], errors="coerce")
    df["Heat_abs"] = mae.abs()
    valid_heat = df["Heat_abs"].dropna()
    df["Typical Heat"] = _bucket_by_quantiles(df["Heat_abs"], ["Low", "Medium", "High"]) if len(valid_heat) >= 5 else "Medium"

    # 4) Peak Keep % from realized PnL vs Trade MFE
    mfe = pd.to_numeric(df["Trade MFE"], errors="coerce")
    df["PeakKeep"] = np.where(mfe > 0, df["PnL_effective"] / mfe, np.nan)
    df["PeakKeep_clipped"] = df["PeakKeep"].clip(lower=-2, upper=2)  # display sanity

    # Closed trades: last 20 by close date (join-anytime view)
    closed = df[df["Status"] == "Closed"].copy().sort_values("Close Timestamp", ascending=False)
    closed_recent = closed.head(20).copy()

    # Open trades
    open_trades = df[df["Status"] == "Open"].copy().sort_values("Open Timestamp", ascending=False)

    # Summary stats for last 20 closed trades
    def profit_factor(pnls: pd.Series) -> float:
        pnls = pnls.dropna()
        wins = pnls[pnls > 0].sum()
        losses = pnls[pnls < 0].sum()
        if losses == 0:
            return float("inf") if wins > 0 else float("nan")
        return float(wins / abs(losses))

    last20_pnls = pd.to_numeric(closed_recent["PnL_effective"], errors="coerce")
    win_rate = (last20_pnls > 0).mean() * 100 if len(last20_pnls.dropna()) else np.nan
    pf = profit_factor(last20_pnls)

    typical_peak_days = float(closed_recent["TimeToPeak_days"].median()) if closed_recent["TimeToPeak_days"].notna().any() else np.nan
    typical_heat = float(closed_recent["Heat_abs"].median()) if closed_recent["Heat_abs"].notna().any() else np.nan

    pk = closed_recent["PeakKeep"].replace([np.inf, -np.inf], np.nan).dropna()
    peak_keep_med = float(pk.median()) if len(pk) else np.nan

    # Tables
    def build_table(sub: pd.DataFrame, title: str) -> str:
        view = pd.DataFrame({
            "Symbol": sub["Symbol"],
            "Structure": sub["Tags"],
            "Strikes": sub["Strikes"],
            "Status": sub["Status"],
            "Ease to Fill": sub["Ease to Fill"].astype(str),
            "Patience Window": sub["Patience Window"].astype(str),
            "Typical Heat": sub["Typical Heat"].astype(str),
            "Peak Keep %": (sub["PeakKeep_clipped"] * 100).round(0),
            "PnL": sub["PnL_effective"],
            "% Return": sub["ReturnPct_effective"],
            "Opened": sub["Open Timestamp"].dt.strftime("%Y-%m-%d"),
            "Closed": sub["Close Timestamp"].dt.strftime("%Y-%m-%d"),
        })

        view["Peak Keep %"] = view["Peak Keep %"].apply(lambda x: "" if pd.isna(x) else f"{x:.0f}%")
        view["PnL"] = view["PnL"].apply(lambda x: "" if pd.isna(x) else f"{x:,.0f}")
        view["% Return"] = view["% Return"].apply(lambda x: "" if pd.isna(x) else f"{x:,.2f}%")
        view["Closed"] = view["Closed"].fillna("—")

        return f"<h2>{title}</h2>\n" + view.to_html(index=False, escape=True, classes="table")

    closed_table = build_table(closed_recent, "Last 20 Closed Trades (join-anytime view)")
    open_table = build_table(open_trades, "Open Trades (current positions)")

    pf_disp = "∞" if pf == float("inf") else ("" if pd.isna(pf) else f"{pf:.2f}")
    win_disp = "" if pd.isna(win_rate) else f"{win_rate:.0f}%"
    peak_disp = "" if pd.isna(typical_peak_days) else f"{typical_peak_days:.0f} days"
    heat_disp = "" if pd.isna(typical_heat) else f"{typical_heat:,.0f}"
    pk_disp = "" if pd.isna(peak_keep_med) else f"{peak_keep_med*100:.0f}%"

    html = f"""<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>SOT Trade Snapshot Report</title>
  <style>
    :root {{
      --bg: #0b0f14; --card: #111827; --text: #e5e7eb; --muted: #9ca3af;
      --border: #1f2937;
    }}
    body {{
      margin: 0; padding: 28px; background: var(--bg); color: var(--text);
      font: 14px/1.4 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial;
    }}
    .wrap {{ max-width: 1200px; margin: 0 auto; }}
    h1 {{ margin: 0 0 6px; font-size: 22px; }}
    p.lead {{ margin: 0 0 18px; color: var(--muted); max-width: 900px; }}
    .cards {{
      display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 12px; margin: 14px 0 20px;
    }}
    .card {{
      background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 12px 14px;
    }}
    .k {{ color: var(--muted); font-size: 12px; }}
    .v {{ font-size: 20px; margin-top: 4px; }}
    .sub {{ color: var(--muted); font-size: 12px; margin-top: 6px; }}
    h2 {{ margin: 22px 0 10px; font-size: 16px; }}
    .table {{
      width: 100%; border-collapse: collapse; background: var(--card);
      border: 1px solid var(--border); border-radius: 14px; overflow: hidden;
    }}
    .table th, .table td {{
      padding: 9px 10px; border-bottom: 1px solid var(--border);
      vertical-align: top; white-space: nowrap;
    }}
    .table th {{
      text-align: left; font-weight: 600; color: #d1d5db; background: #0f172a;
      position: sticky; top: 0; z-index: 1;
    }}
    .table tr:hover td {{ background: rgba(255,255,255,0.04); }}
    .note {{ margin-top: 12px; color: var(--muted); font-size: 12px; }}
    @media (max-width: 1000px) {{ .cards {{ grid-template-columns: repeat(2, minmax(0, 1fr)); }} body {{ padding: 18px; }} }}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Trade Snapshot Report</h1>
    <p class="lead">
      A trade-focused, join-anytime view: simple labels that help subscribers with fills, patience, heat, and profit-taking—without needing portfolio compounding.
    </p>

    <div class="cards">
      <div class="card"><div class="k">Win rate (last 20 closed)</div><div class="v">{win_disp}</div></div>
      <div class="card"><div class="k">Profit Factor (last 20 closed)</div><div class="v">{pf_disp}</div></div>
      <div class="card"><div class="k">Typical patience window</div><div class="v">{peak_disp}</div><div class="sub">Median time to peak</div></div>
      <div class="card"><div class="k">Typical heat</div><div class="v">{heat_disp}</div><div class="sub">Median max drawdown magnitude</div></div>
    </div>

    <div class="card">
      <div class="k">Legend</div>
      <div class="sub">
        <b>Ease to Fill</b> = volume proxy (Hard/Normal/Easy) •
        <b>Patience Window</b> = time-to-peak proxy (Fast/Medium/Slow) •
        <b>Typical Heat</b> = max adverse excursion proxy (Low/Medium/High) •
        <b>Peak Keep %</b> = realized PnL vs best unrealized profit (MFE)
      </div>
      <div class="note">Peak Keep % appears only when MFE &gt; 0; values may be clipped if the source data has artifacts.</div>
    </div>

    {closed_table}
    {open_table}

    <div class="note">Tip: if you later add bid/ask width + OI (e.g., ORATS confidence / mwAdj30), you can refine “Ease to Fill” beyond volume.</div>
  </div>
</body>
</html>
"""
    return html


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate a subscriber-friendly trade snapshot HTML report from a TradesViz CSV export.")
    parser.add_argument("--input", "-i", required=True, help="Path to input CSV (TradesViz export).")
    parser.add_argument("--output", "-o", default="trade_snapshot_report.html", help="Path to output HTML file.")
    args = parser.parse_args()

    in_path = Path(args.input).expanduser()
    out_path = Path(args.output).expanduser()

    df = pd.read_csv(in_path)
    html = build_report(df)
    out_path.write_text(html, encoding="utf-8")
    print(f"Wrote: {out_path.resolve()}")


if __name__ == "__main__":
    main()
